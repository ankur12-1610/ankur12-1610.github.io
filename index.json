[{"content":"This is the way of hacking JWT tokens signed using weak keys. We will be using John The Ripper for determining the correct signing key!\nJWT tokens Introduction JSON Web Token (JWT) is an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret with the HMAC algorithm.\nJWT Tokens consist of three parts seperated by dots (.), which are:\nHeader\nPayload\nSignature\nJWT Token typically looks like: aaaa.bbbb.cccc\nBreaking down the different parts:\nHow it works? The whole process is called signing the JWT token. The signing algorithm takes the header, the payload, and the secret to create a unique signature. Next step is the verification of the token, once the JWT is received, the verification will take its header and payload, and together with the secret that is still saved on the server, basically create a test signature. But the original signature that was generated when the JWT was first created is still in the token, right? And that\u0026rsquo;s the key to this verification. Because now all we have to do is to compare the test signature with the original signature. And if the test signature is the same as the original signature, then it means that the payload and the header have not been modified. Initial Scenario The scenario consists of a REST API running on a target machine and uses JWT-based authorization.\nNote: The signing key used for token generation is weak and the REST API is present in the repo itself.\nImplementation Step 1: Check the presence oh the REST API.\nCommand: curl 127.0.0.1:500\nStep 2: Getting the JWt Token for the user with username user1.\nCommand: curl --location --request GET 'http://127.0.0.1:5000/login' \\ --header 'Authorization: Basic dXNlcjE6ODk4OQ==' \\ --data-raw ''\nThe response contains the JWT Token for the user.\nStep 3: Decoding the token header and payload parts using https://jwt.io.\nThe token uses HS256 algorithm (a symmetric signing key algorithm).\nSince it is mentioned in the challenge description that a weak secret key has been used to sign the token and the constraints on the key are also specified, a bruteforce attack could be used to disclose the correct secret key.\nStep 4: We\u0026rsquo;ll be using John The Ripper (jtr) for performing the bruteforce attack. For installing jtr follow the give command: sudo apt-get install john -y or sudo snap install john-the-ripper\nTo check if it is installed type john in the terminal.\nStep 5: Save the JWT Token obtained in Step 2 into a file called jwt.txt.\nStep 6: Generate a wordlist used for brute-forcing the signing-key: Save the following Python script as generate-wordlist.py:\nfp = open(\u0026#34;wordlist.txt\u0026#34;, \u0026#34;w\u0026#34;) for i in range (10): for j in range (10): for k in range (10): for l in range (10): fp.write(str(i) + str(j) + str(k) + str(l) + \u0026#34;\\n\u0026#34;); fp.close() Run the above python script to generate the wordlist. Command: python3 generate-wordlist.py\nStep 7: The final step is to burte-force the signing key: Command: john jwt.txt --wordlist=wordlist.txt --format=HMAC-SHA256\nStep 8: Since the secret key for signing the token is known, it can be used to create a valid token. Use https://jwt.io to create a new token. Over here we change the username of the user in order to obtain a new token which can only be used by user2 and not user1. Since the signing key is already known, the username of the user could be changed and the corresponding token would be generated.\nNow this forged token will allow user1 to access the secrets which were only allowed to user2.\nuser1 is authenticated and the user is able to see the secret namely, password1 for the token generated with the username-user1\nNow, as the new token is forged, user1 has the token corresponding to user2. which enables user1 to get an acess to user2\u0026rsquo;s secret.\n","permalink":"https://ankur12-1610.github.io/posts/hack-jwt/","summary":"This is the way of hacking JWT tokens signed using weak keys. We will be using John The Ripper for determining the correct signing key!\nJWT tokens Introduction JSON Web Token (JWT) is an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret with the HMAC algorithm.","title":"Hacking JWT Tokens: By Bruteforcing Weak Signing Key"},{"content":" I have always wanted to participate in the LFX Mentorship program and here I am, graduated, writing this blog. These 3 months were amazing! This blog covers my experience in this mentorship.\nWhat’s the LFX Mentorship? “The Linux Foundation Mentorship Program is designed to help developers — many of whom are first-time open source contributors — with necessary skills and resources to learn, experiment, and contribute effectively to open source communities. By participating in a mentorship program, mentees have the opportunity to learn from experienced open source contributors as a segue to get internship and job opportunities upon graduation.”\nIf you are interested in participating in the LFX Mentorship programs, you can find more information at lfx.linuxfoundation.org/mentorship/guide.\nMy acceptance into the program Once the application process began, I drafted a cover letter and I was contributing to TestGrid for some time which I included in my cover letter, which I believe helped me stand out from other candidates.\nI want to emphasize that contributions matter a lot. If you are interested in a particular organization, I encourage you to find ways to contribute to their community or projects. This is a great way to show your interest in the organization and your ability to add value.\nI applied to 3 organizations (Kubernetes, Harbor and Cortex), Kubernetes accepted me first, so my applications to the other two organizations were no longer considered.\nSo, what did you do during mentorship? I contributed to CNCF - TestGrid: Frontend development inside Lit Component Framework project.\nTestGrid\u0026rsquo;s Core contributors Michelle Shepardson and Sean Chase were my mentors. I had weekly sync-up meetings with them. In this meeting, we reviewed the goals we set in our previous meetings, discussed the progress, reviewed PRs I made, and identified any new goals or objectives that I would like to work towards.\nStepwise progress:\nFrontend:\nThe first step was to set up an existing webapp with Tailwind, after searching it was found that having normal plain old CSS is suited for Lit Framework. Therefore, we decided to build our components on top of plain old CSS.\nNext, I implemented the index of TestGrid which rendered dashboard and dashboard groups components. The image shows the end result of the index.\nImplemented the onClick functionality to render particular dashboards when clicked on a dashboard group. Refer to this image:\nAfter implementing the index, Sean asked me to write StoryBook and Unit tests, following the Test-Driven Development (TDD) methodology. This was my first time writing Storybook tests, and I found it to be a fun and rewarding experience.\nI also decluttered the codebase by removing any unused or duplicate code.\nThe final task which revolved around fronted was to reiterate and improve the written tests.\nBackend:\nAfter, implementing the index, there was some problem in the API structure which made the frontend do the heavy work. Hence, compromising the user experience.\nAfter discussing it with my mentors we decided that the API structure needs to be improved and I was set to start my GO journey, was really excited!\nI really want to thank Michelle and Sean (my mentors) as they helped me get familiar with every piece of information related to API and GO. Before actually working on the codebase, I read all the resources first and got familiar with protubufs and GO.\nThere were two tasks assigned to me;\nTask1: (refer to issue #1199)\nThe frontend required to do heavy work because the dashboards were not linked to their respective dashboard groups. The solution was simple, just add a reference to every dashboard of their dashboard group. I updated the API proto, wrote the governing functions, and finally updated the tests.\nTask2: (refer to issue #1200)\nCurrently, TestGrid doesn\u0026rsquo;t have an endpoint that shows the config in a short and clear way. The information we get related to a particular tab is by fetching headers or rows. The end goal was to add a new endpoint that shows all the valid and important information related to the dashboard tab.\nI started by creating a new resource in the API proto. Later on, I added the governing functions which fetch the equivalent data. Finally registered a new endpoint to the server.\nWhat I Achieved and Scope for Improvement I was having real fun working on this project and have closed 5 PRs and have 1 PR in progress.\nCurrently, the Task2 PR is still a work in progress, my goal is to complete the task and get the WIP PR merged.\nI am also looking forward to contributing to Kubernetes in the future.\nIs it difficult to get accepted into this? I would say a big NO!!!\nI personally started checking out the projects a few weeks before the applications started.\nIt is all about how willing are you to contribute to the community and learn new things which at the start might seem a little bit overwhelming. Before LFX, I was a beginner in GO but during my mentorship period, I worked on an API written in GO.\nDon\u0026rsquo;t hesitate, give it a try. You will learn a lot!\nIf you’re interested in joining the LFX Mentorship like I was, submit your proposal here!\nGraduation and concluding it all! After 12 weeks, I successfully graduated from the program-\nI\u0026rsquo;m really grateful to my mentors Michelle Shepardson and Sean Chase for helping me throughout the project. Additionally, a big thanks to Sultan Duisenbay, who helped me a lot as well!\nI would like to express my sincere gratitude to the Kubernetes, LFX, and CNCF communities. Without their support, neither this project nor this program would have been possible.\nFor doubts and questions feel free to contact me: LinkedIn | Gmail\nThank you for reading, hope you enjoyed the article! Follow me on Twitter | LinkedIn for more development-related posts. That\u0026rsquo;s all for today! Thank you for reading :)\n","permalink":"https://ankur12-1610.github.io/posts/journey-lfx/","summary":"I have always wanted to participate in the LFX Mentorship program and here I am, graduated, writing this blog. These 3 months were amazing! This blog covers my experience in this mentorship.\nWhat’s the LFX Mentorship? “The Linux Foundation Mentorship Program is designed to help developers — many of whom are first-time open source contributors — with necessary skills and resources to learn, experiment, and contribute effectively to open source communities.","title":"My LFX Mentorship Journey with CNCF: Kubernetes"},{"content":" On May 1, I received an email saying that I was one of the 82 interns selected amongst 20317 applicants for the Summer of Bitcoin 2022 program.\nI was really happy and surprised as I didn\u0026rsquo;t have any high hopes at that time. This blog covers my journey of getting selected into the program from the very beginning.\nSo everyone might be asking a question: What is Summer of Bitcoin?\nBefore answering that question I would like to share my takeaways from it :)\nTakeaways Before Summer of Bitcoin, I literally had zero experience with blockchain and bitcoin all I knew was about hashing and salting, not more than that. This program not only gave me a Bitcoin learning experience but it was my first major OSS contribution, I used to make small APIs but at the end of this, I actually not only created new APIs but also improved their auth system via access tokens.\nTo make things amazing we also got a Hardware Crypto Wallet (Ledger Nano S), swags, T-shirt, a Bitcoin-Genesis imprinted mug, a book, and a Laptop bag!\nLast but not least, I made contacts with really amazing people who were pros in the Blockchain space!\nWhat is Summer of Bitcoin? A global program that matches students with open source, free software, and technology-related organizations working on bitcoin to write code and become part of these communities while making some BTC along the way! The organizations provide mentors who act as guides through the entire process, from learning about the community to contributing code. Students get involved in and become familiar with the bitcoin open source community and put their summer break to good use.\nTo know more visit the Summer Of Bitcoin website.\nSelection Process How I came to know about Summer of Bitcoin? I heard about the program in a general discussion held amongst my seniors of the Club of Programmers, IIT BHU and it really caught my attention. I visited their website and gathered all the information that was present on the website.\nRound 1: Application Round In this round students apply to a track (Designer or Developer) of their choice. Students need to write essays.\nBe truthful and original to yourself, don\u0026rsquo;t copy from any random sites.\nRound 2: Screening Round In this round, student applicants receive a screening assignment based on their applied track.\nThe questions are generally based on basic DSA. The peeps with a good hold on DSA might not face any difficulty giving the test.\nNote: Applicants with a strong rating on any coding platform, or applicants having prior experience with GSoC or an equivalent open-source program will be eligible to proceed directly to the next round.\nRound 3: Proposal Round Students who successfully complete the screening assignment are invited to an exclusive discord server where they are provided with resources to learn about bitcoin, ask questions, and write project proposals based on the project ideas published on the official Summer of Bitcoin website.\nThis round lasts about one month, in which we\u0026rsquo;re given resources related to Bitcoin. Moreover, discussions take place in a week or two on the topics given. Lastly, organizations are announced and their respective projects, so by this time you start contributing and start writing the proposal.\nShortlisting organizations is something that is really important, one must shortlist an organization based on the interest, tech stack, and competition as well. I jotted down the list of organizations, deep-dived into their projects, and finally found an apt one. It was Specter Desktop\u0026rsquo;s: Acces tokens for the REST API\nThis period of the program was really awesome since I learned a lot, personally, it was this period that gave me my first-ever Bitcoin exposure!\nRound 4: Interview After getting shortlisted by the organizations, they call you up for an interview. Here I was asked about my knowledge of Bitcoin and Blockchain, and most importantly about the project on which I wrote the proposal.\nMy Experience Project Specific Once the results were announced, we were asked to contact our respective mentors, I was assigned with these amazing guys k9ert and Manolis, I literally had no idea how to start my work but my mentors really helped me with it. Before working on the project I did some contributions to Specter Desktop which made me familiar with the codebase. Weekly scrums really helped me to keep my progress on track as they cleared my doubts and we used to discuss enhancements that can be made to the project. I really loved working on this project and contributing!\nI\u0026rsquo;ve written blogs on my Summer of Bitcoin work:\nMidterm Work: https://my-blog.ankurrev.tech/specter-sob-1\nFinal Work: https://my-blog.ankurrev.tech/specter-sob-final\nWeekly Seminars For the first 5 weeks every Thursday, we had seminars on Bitcoin Protocol Development. These seminars are based on Chaincode Seminars. The topics they covered were:\nWeek 1: Welcome to Bitcoin Protocol Development\nWeek 2: Segwit\nWeek 3: Mining \u0026amp; Network Block Propagation\nWeek 4: P2P\nWeek 5: Script \u0026amp; Wallets\nEvery week, we were assigned a partner, resources, and a discussion question. We worked with our partners to brainstorm answers to that question. Then every week we met in a breakout room and discuss our findings with everyone else. It was so much fun learning and sharing our research with our peers.\nResources These resources will help you with the fundamentals of Bitcoin and some of them will allow you to dig deeper. Studying them will help you understand Bitcoin in order to prepare better project proposals.\nGrokking Bitcoin by Kalle Rosenbaum ( must read! ) | Videos of the same book\nBitcoin Whitepaper (must read !)\nMastering Bitcoin covers more of a technical aspect of Bitcoin.\nWhat has Government Done to Our Money by Murray N. Rothbard\nAn exhaustive list of Bitcoin resources ( For more depth )\nAnd most important one is chaincode.gitbook.io/seminars but for this, you must have a good understanding of the Bitcoin fundamentals.\nConclusion I\u0026rsquo;m not sure if Summer of Bitcoin will have the same exact selection procedure as they did this year because it was somewhat different in 2021 as well, can\u0026rsquo;t comment on that but I\u0026rsquo;m sure that the pattern will remain the same.\nThe applications will most probably start from the January 1st week so be prepared. You will find a new timeline on their website. To keep getting updates to follow @summerofbitcoin.\nMoreover, I\u0026rsquo;m really grateful to Adi Shankara, k9ert, and Manolis for this amazing learning experience.\nFor those who are looking forward to applying for the next cohort of Summer of Bitcoin, all the best guys :) For doubts and questions feel free to contact me: LinkedIn | Gmail\nThank you for reading, hope you enjoyed the article! Follow me on Twitter | LinkedIn for more development-related posts. That\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/journey-sob/","summary":"On May 1, I received an email saying that I was one of the 82 interns selected amongst 20317 applicants for the Summer of Bitcoin 2022 program.\nI was really happy and surprised as I didn\u0026rsquo;t have any high hopes at that time. This blog covers my journey of getting selected into the program from the very beginning.\nSo everyone might be asking a question: What is Summer of Bitcoin?","title":"My Journey: Getting Selected in Summer of Bitcoin '22"},{"content":" Abstract This blog covers the work that I\u0026rsquo;ve done post mid-term evaluation. In the last part, I implemented the token generation part which included generating and saving the token in the users.json file, which acts as the local database of the user.\nImplementation Some things took a considerable amount of time and energy, as they needed to be discussed with the mentors.\nChange in plans Initially, the data was stored in individual entities, which resulted in creating several hashmaps which weren\u0026rsquo;t necessary. After discussing with Kim and Manolis, we concluded that all the information related to the JWT tokens should be stored in a nested hashmap instead of storing it in separate entities. Storing it in separate entities created unnecessary crowding of variables and a nested hashmap was perfect to tackle this problem.\nThe fields related to the JWT token that needed to be stored:\nEarlier, the data was stored in the format: Later, the data was stored in the format of nested hashmap: Token Authentication Implementing Token Authentication was the most important and challenging part of this project. Specter used Flask-HTTPAuth for their Basic Authentication, which I was not entirely familiar with ;')\nAfter reading the documentation and experimenting with the Token Authentication part in a small project, I cleared my basic concepts and hoped on the project\u0026rsquo;s codebase.\nThe first step was to decode the JWT token to get the payload, and from that payload, I grepped the username of the user.\nThe next step was to get the user from username with the help of Specter\u0026rsquo;s user_manager and then store it in the global user.\nThe final check was to add jwt.ExpiredSignatureError, to check whether the token is expired or not and jwt.InvalidTokenError, to check whether the token is in a valid format or not.\nTime Parser The expiration time in the payload while encoding the token could only be set to either seconds or minutes or days or any time unit. The problem was that, if the standard time is set to seconds and the user wants his token to be valid for 3 days, he might need to convert 3 days to seconds.\nIn order to avoid this, I used pytimeparser, which basically converts the string into seconds. For eg: If the user sets the time to 3 days then the parser will convert it to seconds (3 days = 259200 seconds) and then it can be easily stored in the database. Similarly, the user can set the token life to 3 minutes, 3 weeks, 3 months and other time units as well.\nNote: For more information regarding pytimeparser visit: https://pypi.org/project/pytimeparse/\nHelper Functions Building these functions made the implementation a lot easier, once written they can be used anywhere and one helper function helped me build other helper functions.\nFor example:\nThe helper functions for saving a newly created token to the database and deleting the token from the database.\ndef add_jwt_token( self, jwt_token_id, jwt_token, jwt_token_description, jwt_token_life ): # Adding a newly created JWT to the hashmap self.jwt_tokens[jwt_token_id] = {} self.jwt_tokens[jwt_token_id][\u0026#34;jwt_token\u0026#34;] = jwt_token self.jwt_tokens[jwt_token_id][\u0026#34;jwt_token_description\u0026#34;] = jwt_token_description self.jwt_tokens[jwt_token_id][\u0026#34;jwt_token_life\u0026#34;] = jwt_token_life self.save_info() def delete_jwt_token(self, jwt_token_id): # Deleting a JWT from the hashmap if jwt_token_id in self.jwt_tokens: del self.jwt_tokens[jwt_token_id] self.save_info() Endpoints /v1alpha/token/: Creating new tokens and fetching all of them. ** Method **: POST\nCode: 201 Created\nRequest Body:\n{ \u0026#34;jwt_token_description\u0026#34;: \u0026#34;Token alpha\u0026#34;, \u0026#34;jwt_token_life\u0026#34;: \u0026#34;6 minutes\u0026#34;, } Success Response:\n{ \u0026#34;message\u0026#34;: \u0026#34;Token generated\u0026#34;, \u0026#34;jwt_token_id\u0026#34;: \u0026#34;2bc0160d-edf4-4ab6-9801-52d185f65b59\u0026#34;, \u0026#34;jwt_token\u0026#34;: \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiand0X3Rva2VuX2lkIjoiMmJjMDE2MGQtZWRmNC00YWI2LTk4MDEtNTJkMTg1ZjY1YjU5Iiwiand0X3Rva2VuX2Rlc2NyaXB0aW9uIjoiVG9rZW4gYWxwaGEiLCJleHAiOjE2NjEzMTg3NjIsImlhdCI6MTY2MTMxODQwMn0.MWbUuZ8BS5L9kryi_zG_PNJ4ud84mPuJhsqhiH_U5Rc\u0026#34;, \u0026#34;jwt_token_description\u0026#34;: \u0026#34;Token alpha\u0026#34;, \u0026#34;jwt_token_life\u0026#34;: 360 } Method: GET\nCode: 200 OK\nSuccess Response:\n{ \u0026#34;message\u0026#34;: \u0026#34;Tokens exists\u0026#34;, \u0026#34;jwt_tokens\u0026#34;: { \u0026#34;edd6a8f7-47d8-405e-97a8-2e4e26d0fbeb\u0026#34;: { \u0026#34;jwt_token_description\u0026#34;: \u0026#34;Token 1\u0026#34;, \u0026#34;jwt_token_life\u0026#34;: 480, \u0026#34;jwt_token_remaining_life\u0026#34;: 0 }, \u0026#34;2bc0160d-edf4-4ab6-9801-52d185f65b59\u0026#34;: { \u0026#34;jwt_token_description\u0026#34;: \u0026#34;Token alpha\u0026#34;, \u0026#34;jwt_token_life\u0026#34;: 360, \u0026#34;jwt_token_remaining_life\u0026#34;: 232.19542360305786 } } } /v1alpha/token/\u0026lt;token_id\u0026gt;: Fetching and deleting a particular token by Id. Method: GET\nCode: 200 OK\nSuccess Response:\n{ \u0026#34;message\u0026#34;: \u0026#34;Tokens exists\u0026#34;, \u0026#34;jwt_token_description\u0026#34;: \u0026#34;Token alpha\u0026#34;, \u0026#34;jwt_token_life\u0026#34;: 360, \u0026#34;jwt_token_life_remaining\u0026#34;: 232.19542360305786, \u0026#34;expiry_status\u0026#34;: \u0026#34;Valid\u0026#34; } Method: DELETE\nCode: 200 OK\nSuccess Response:\n{ \u0026#34;message\u0026#34;: \u0026#34;Token deleted\u0026#34; } Project Details: For more info, visit the PR related to this project: https://github.com/cryptoadvance/specter-desktop/pull/1785\nFuture Idea: This implementation of `JWT Token-Based Authentication` is fairly straightforward and clearly helps improve the security of Specter\u0026rsquo;s API.\nThe following things can be added to the project:\ncreating a UI for it\nadding one more property to tokens, namely endpoints which will store the endpoints the user can access\nLearning: - Through this journey, I learned a lot about how open source projects work, getting involved with the community, and contributing to the projects. - The major learning for me was how familiar I got with `Flask-RESTful` framework and `Flask-HTTPAuth`.\nSpecial Thanks It was an awesome experience for me to work on this project. I learned a lot of new things, Kim and Manolis really helped me whenever I got stuck.\nI would also like to give Adi Shankara and Summer of Bitcoin for this amazing learning experience. I was able to develop great skills and valuable experience. I look forward to contributing to the Bitcoin space.\nAlso, super thanks for the Ledger Nano S and an awesome Swag Kit ;) ment\nConclusion: Thank you for reading, hope you enjoyed it! I\u0026rsquo;ll continue to update my progress via the series of blogs ;)\nFollow me on Twitter | LinkedIn for more web development-related tips and posts.\nThat\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/sob-part2/","summary":"Abstract This blog covers the work that I\u0026rsquo;ve done post mid-term evaluation. In the last part, I implemented the token generation part which included generating and saving the token in the users.json file, which acts as the local database of the user.\nImplementation Some things took a considerable amount of time and energy, as they needed to be discussed with the mentors.\nChange in plans Initially, the data was stored in individual entities, which resulted in creating several hashmaps which weren\u0026rsquo;t necessary.","title":"Access tokens for Specter's REST API: Part 2 | Summer of Bitcoin '22"},{"content":" Abstract Specter Desktop is a desktop GUI for Bitcoin Core optimized to work with hardware wallets.\nSpecter already has a REST API system, but the authorization is currently done by HTTPBasicAuth and to improve the security, HTTPTokenAuth is really necessary. Access tokens would be a significant improvement.\nMy Project I have to use access tokens for the token-based authorization, the access token I opted for was JSON Web Token (JWT) because:\nI have already used it\nI read their official documentation and got a fan of JWT and its advantages over Simple WebToken (SWT) and Security Assertion Markup Language Tokens (SAML). source\nJWT authentication flow\nExpected Outcomes:\nUser will be able to create a JWT token when the request is sent to a particular endpoint of the api\nOnce the token is generated the user can only see it once and the token needs to be stored somewhere in order to access sessions later on.\nAuthorization will be based on HTTPTokenAuth\nProject Progress Headstart 🚀 At first, when I went through Specter\u0026rsquo;s codebase it was difficult for me to understand and I was not able to figure out where to make the changes, but thanks to my mentor (k9ert) who helped me sort things out when I was stuck. He suggested making a small FLASK API in a similar structured way as Specter\u0026rsquo;s API was made. This really helped me understand Flask-RESTful and Flask_HTTPAuth.\nPoC Implementation 📖 Step 1\nThe very first step was to install PyJWT:\npip install PyJWT Next, we need to create a \u0026lsquo;jwt_token\u0026rsquo; variable in the UserMixinof src/cryptoadvance/specter/user.py, then we pass it in the user_dict with the help of a property.\nclass User(UserMixin): def __init__( ... jwt_token, ... ): ... self.jwt_token = jwt_token ... # TODO: User obj instantiation belongs in UserManager @classmethod def from_json(cls, user_dict, specter): try: user_args = { ... // Setting default value of jwt_token to None so that it can be stored in the user\u0026#39;s data and then later on updated \u0026#34;jwt_token\u0026#34;: user_dict.get(\u0026#34;jwt_token\u0026#34;, None), ... } if not user_dict[\u0026#34;is_admin\u0026#34;]: user_args[\u0026#34;config\u0026#34;] = user_dict[\u0026#34;config\u0026#34;] return cls(**user_args) else: user_args[\u0026#34;is_admin\u0026#34;] = True return cls(**user_args) except Exception as e: handle_exception(e) raise SpecterError(f\u0026#34;Unable to parse user JSON.:{e}\u0026#34;) @property def json(self): user_dict = { ... \u0026#34;jwt_token\u0026#34;: self.jwt_token, ... } if not self.is_admin: user_dict[\u0026#34;config\u0026#34;] = self.config return user_dict We also need to add helper functions in order to fetch and delete the token:\ndef save_jwt_token(self, jwt_token): self.jwt_token = jwt_token self.save_info() def delete_jwt_token( self, ): self.jwt_token = None self.save_info() Step 2\nThis step includes the creation of token based endpoints in the API. For this I created a new file namely jwt.py in the rest directory.\nDirectory tree\nimport jwt from flask import current_app as app from cryptoadvance.specter.api.rest.base import ( BaseResource, rest_resource, AdminResource, ) import uuid import datetime import logging from ...user import * from .base import * from .. import auth logger = logging.getLogger(__name__) def generate_jwt(user): payload = { \u0026#34;user\u0026#34;: user.username, \u0026#34;exp\u0026#34;: datetime.datetime.utcnow() + datetime.timedelta(days=1), } return jwt.encode(payload, app.config[\u0026#34;SECRET_KEY\u0026#34;], algorithm=\u0026#34;HS256\u0026#34;) @rest_resource class TokenResource(AdminResource): endpoints = [\u0026#34;/v1alpha/token/\u0026#34;] def get(self): user = auth.current_user() user_details = app.specter.user_manager.get_user(user) jwt_token = user_details.jwt_token return_dict = { \u0026#34;username\u0026#34;: user_details.username, \u0026#34;id\u0026#34;: user_details.id, \u0026#34;jwt_token\u0026#34;: jwt_token, } if jwt_token is None: return_dict[\u0026#34;jwt_token\u0026#34;] = generate_jwt(user_details) jwt_token = return_dict[\u0026#34;jwt_token\u0026#34;] user_details.save_jwt_token(jwt_token) return { \u0026#34;message\u0026#34;: \u0026#34;Token generated\u0026#34;, \u0026#34;username\u0026#34;: user_details.username, \u0026#34;jwt_token\u0026#34;: jwt_token, } return {\u0026#34;message\u0026#34;: \u0026#34;Token already exists\u0026#34;, \u0026#34;jwt_token\u0026#34;: jwt_token} def delete(self): user = auth.current_user() user_details = app.specter.user_manager.get_user(user) jwt_token = user_details.jwt_token if jwt_token is None: return {\u0026#34;message\u0026#34;: \u0026#34;Token does not exist\u0026#34;} user_details.delete_jwt_token() return {\u0026#34;message\u0026#34;: \u0026#34;Token deleted\u0026#34;} This basically includes the function generate_jwt which takes user as an argument and generates the token with the payload as user.username and the expiry date of the token (exp).\nThen we have two endpoints - GET and DELETE which receive data from the User model using user_manager by passing the authenticated user.\nGET request functionality\nDELETE request functionality\nLast Step\nThe last step is to register the endpoints in the API, this can be done by adding:\nfrom .jwt import TokenResource in src/cryptoadvance/specter/api/rest/api.py\nPR related to this project https://github.com/cryptoadvance/specter-desktop/pull/1785\nDemo of the implemented PoC:\nFuture milestones\nThe plans for the rest of my journey are:\nAdding a verfiy_token function that verifies if the given token is correct or not.\nReplacing HTTPBasicAuth with HTTPTokenAuth\nAdd one-time view functionality for the users.\nConclusion Thank you for reading, hope you enjoyed it! I\u0026rsquo;ll continue to update my progress via the series of blogs ;)\nFollow me on Twitter | LinkedIn for more web development-related tips and posts.\nThat\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/sob-part1/","summary":"Abstract Specter Desktop is a desktop GUI for Bitcoin Core optimized to work with hardware wallets.\nSpecter already has a REST API system, but the authorization is currently done by HTTPBasicAuth and to improve the security, HTTPTokenAuth is really necessary. Access tokens would be a significant improvement.\nMy Project I have to use access tokens for the token-based authorization, the access token I opted for was JSON Web Token (JWT) because:","title":"Access tokens for Specter's REST API: Part 1 | Summer of Bitcoin '22"},{"content":"Introduction: All of us at some part of our software development journey has most likely heard of Vim.\nVim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as \u0026ldquo;vi\u0026rdquo; with most UNIX systems and with Apple OS X.\nVim is rock stable and is continuously being developed to become even better. Among its features are: persistent, multi-level undo tree extensive plugin system support for hundreds of programming languages and file formats powerful search and replace integrates with many tools\nVim is an old school, too linux way editor, and it takes a bit of effort to do all the customizations. This is where SpaceVim steps in, it makes things way easier for the user.\nSpaceVim is a distribution of the Vim editor that’s inspired by spacemacs. It manages collections of plugins in layers, which help collect related packages together to provide features. This approach helps keep configuration organized and reduces overhead for the user by keeping them from having to think about what packages to install.\nWhat is SpaceVim? SpaceVim is .vim in your home directory, this is the simplest explanation of SpaceVim. In general, vim will try to find ~/.vimrc in your home directory. If there is no such file. vim will use ~/.vim/vimrc as the init file.\nThis is how and why SpaceVim can be loaded. If you create a ~/.vimrc in your home directory, SpaceVim will not be loaded automatically.\nDifference between SpaceVim and Vim SpaceVim use layers to manager plugins and config. Users do not need to searching for plugins, also do not need to config them. For example, if you are a golang developer, and want to use use SpaceVim as a simple GO ide. You just need to install SpaceVim, and enable lang#go layer. All plugins will be downloaded automatically.\nWhy use Vim or specifically SpaceVim? VIM is from the era when text mode was the norm, GUI wasn\u0026rsquo;t present and having a mouse was a novelty. Developers at that time didn\u0026rsquo;t have any interest in mimicking GUI in text mode. nor there were any frameworks to do so. the computer wasn\u0026rsquo;t common and the only users were either programmers or mathematicians.\nTo create a program for such an audience in that era would result in what you see as VIM or similar. a blank screen with convoluted and absurd shortcut keys (to quit VI you press :q )\nso the VIM creators designed the app for their target audience according to what was then available- a large blank screen as the work area and various key combinations to invoke some functionality. No menus, no buttons, no progress bars etc.\nMy personal experience with Vim: It was problematic at first but within a day or two when I got hold of various key combinations and installed various plugins, I was able to code pretty quickly as no cursor was needed it was just a keyboard.\nInstallation Prerequisites You need to install Vim with Python support (click here for the installation steps)\nYou need to have git and curl installed in your system, which are needed for downloading plugins and fonts.\nInstalling SpaceVim: Linux and macOS (click here)\nWindows (click here)\nConfiguration The default configuration file of SpaceVim is ~/.SpaceVim.d/init.toml. Users can edit this file to change the configs.\nHere is my ~/.SpaceVim.d/init.toml :)\n[options] # set spacevim theme. by default colorscheme layer is not loaded, # if you want to use more colorscheme, please load the colorscheme # layer colorscheme = \u0026#34;onedark\u0026#34; colorscheme_bg = \u0026#34;dark\u0026#34; # Disable guicolors in basic mode, many terminal do not support 24bit # true colors enable_guicolors = true # Disable statusline separator, if you want to use other value, please # install nerd fonts statusline_separator = \u0026#34;arrow\u0026#34; statusline_iseparator = \u0026#34;arrow\u0026#34; buffer_index_type = 4 enable_tabline_filetype_icon = true enable_statusline_mode = false file_searching_tools = [\u0026#39;find\u0026#39;, \u0026#39;find -not -iwholename \u0026#34;*.git*\u0026#34; \u0026#39;] # Enable autocomplete layer [[layers]] name = \u0026#39;autocomplete\u0026#39; auto_completion_return_key_behavior = \u0026#34;complete\u0026#34; auto_completion_tab_key_behavior = \u0026#34;smart\u0026#34; [[layers]] name = \u0026#39;shell\u0026#39; default_position = \u0026#39;top\u0026#39; default_height = 30 [[layers]] name = \u0026#34;ui\u0026#34; enable_scrollbar = true [[layers]] name = \u0026#34;colorscheme\u0026#34; [[layers]] name = \u0026#34;lang#kotlin\u0026#34; [[layers]] name = \u0026#34;lang#typescript\u0026#34; [[layers]] name = \u0026#39;lang#c\u0026#39; enable_clang_syntax_highlight = true [[layers]] name = \u0026#34;lang#javascript\u0026#34; [[layers]] name = \u0026#34;lang#go\u0026#34; [[layers]] name = \u0026#34;lang#python\u0026#34; [[layers]] name = \u0026#34;default\u0026#34; Important shortcuts For those who are new to vim, visit https://devhints.io/vim to learn basic vim commands.\nThere are different kinds of shortcuts, start with different prefix:\nPrefix Prefix name Example Description More info space [SPC] spc f t open/close filetree just press space key and wait 1s s [WIN] s v split window, equal to :split link \\ \u0026lt;Leader\u0026gt; \\ [0-9] jump to other tab or buffer just press \\ key and wait 1s g go to g 0 go to first tab link z fold z a toggle a fold link ** Most frequently used shortcuts **:\nShortcuts Description Basic h j k l move around spc wait 1 second to get hint for more shortcuts \u0026lt;F3\u0026gt; / spc f t trigger file tree spc t t Open tab manager F2 Open tagbar \u0026lt;Leader\u0026gt; [1-9] switch to different tabs or buffers spc [1-9] switch to different windows ctrl j/h/k/l switch to different windows Filetree Link spc f o open file tree and locate to current directory s g open file and split window horizontally s v open file split window vertically Comment code Link spc c l comment/uncomment current line spc c p/P comment/uncomment current paragraph spc ; [num] j comment num lines Tab Manager Link spc w F open a new tab, equal to spc t t + n spc w o switch tab Display Link spc s c clear search highlight SPC t 8 highlight any character past the 80th column SPC t h h toggle highlight of the current line SPC t h c toggle highlight indentation current column Search Link spc s s Searching in current file spc s d Searching in current directory spc s b Searching in all loaded buffers spc s p Searching in current proj, equal to spc / Useful shortcuts Link [ spc insert space above ] spc insert space below IDE shortcuts:\nShortcuts Description g d Go to function definition spc b f format code according to pep8 standard spc l g d generate docstring spc l r run code (for any language be it python or c) Note: These are the shortcuts that I use the most there are many more that you might use. You can explore them by pressing space-bar in the spacevim, wait a sec and you\u0026rsquo;ll see a window which contains all kinds of shortcuts.\nhttps://github.com/Jackiexiao/10-minutes-to-SpaceVim/blob/master/README.md will give you a good idea about all the shortcuts do visit it :)\nCustomizing SpaceVim to adapt as IDE for different languages The trick is simple you just need to add a layer in ~/.SpaceVim.d/init.tomlof that particular language. For example if I want to use SpaceVim for python I\u0026rsquo;ll add:\n[[layers]] name = \u0026#34;lang#python\u0026#34; Similarly for other languages they have different layers visit their guide of programming language support (click here) for more details.\nConclusion: Thank you for reading, hope you enjoyed the article! Queries and feedback are most welcome :) kindly leave them below.\nFollow me on Twitter | LinkedIn for more web development-related tips and posts.\nThat\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/spacevim/","summary":"Introduction: All of us at some part of our software development journey has most likely heard of Vim.\nVim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as \u0026ldquo;vi\u0026rdquo; with most UNIX systems and with Apple OS X.\nVim is rock stable and is continuously being developed to become even better. Among its features are: persistent, multi-level undo tree extensive plugin system support for hundreds of programming languages and file formats powerful search and replace integrates with many tools","title":"SpaceVim as IDE"},{"content":" Introduction: Automation, complexity reduction, reproducibility, and maintainability are all advantages that can be realized by a continuous integration (CI) pipeline. With GitHub Actions, you can build these CI pipelines.\n\u0026ldquo;Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you\u0026rsquo;d like, including CI/CD, and combine actions in a completely customized workflow.\u0026rdquo; - Github Docs\nWe all use Github Actions for code analysis, adding awesome Readme features and doing many other things. When I was first introduced to Github Actions I was dumbstruck and from then onwards it became my favorite section to explore. I started exploring it, used it in my profile Readme and it was really awesome.\nBut the problem was I was using the products which were created by others and it kind of hurt me😅. So I was like - \u0026ldquo;Let\u0026rsquo;s create a Github Action on own and then publish it in the marketplace so that others can use it\u0026rdquo;. And guess what I did, you can check it on Github. In this blog we are going to make a Github Action so tighten your seat belt, it\u0026rsquo;ll be fun.\nPrerequisites: A Github account Steps: Create a Github repository with a license (any, I\u0026rsquo;ve used MIT License).\nClone the repo to your local machine and open it in your favorite IDE.\nSetup a node project with:\nnpm init and install all the required packages by following commands:\nnpm i @actions/core npm i @actions/exec npm i @actions/github npm i @vercel/ncc @vercel/ncc is a Simple CLI for compiling a Node.js module into a single file.\nAfter installing packages make sure to add this script in package.json: \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;ncc build src/main.js -o dist\u0026#34; } This script is important as it runs @vercel/ncc which compiles all the files to a single file dist/index.js.\nNow, we create an action.yml file in our repository. The action.yml is the metadata file and defines the inputs, outputs, and main entry point for our Action. The action.yml file has to include:\nname: The name of your Github Action.\ndescription: A short description of what your action is doing.\nauthor: The name of the author who created this Github Action.\ninputs: The input parameters which you can pass into your script.\nruns: Defines what the action will execute (in our case, it\u0026rsquo;ll run docker).\nbranding: How your Github Action will look like when it is launched in the marketplace.\nThe action.yml file will look like-\nname: Demo Issue Action 🛰 description: Comments on the newly opened issue. author: ankur12-1610 \u0026lt;anknerd.12@gmail.com\u0026gt; inputs: GITHUB_TOKEN: description: Github token required: true ISSUE_COMMENT: description: Comment to be added on opening an issue required: true branding: color: blue icon: tag runs: using: \u0026#39;docker\u0026#39; image: \u0026#39;Dockerfile\u0026#39; Now, create a folder namely src and in that create a file main.js. This file includes the main script of the action, it is like the brain of the action.\nIn our case, we are creating a Github Action which will comment on every issue created. For this, we need @octokit/rest npm package. It is the GitHub REST API client for JavaScript.\nFor its API endpoints and other details go through its official docs.\nSo my main.js will look like this: const core = require(\u0026#39;@actions/core\u0026#39;) const github = require(\u0026#39;@actions/github\u0026#39;) export async function run() { try { const { context } = require(\u0026#39;@actions/github\u0026#39;) //taking input from the core const GITHUB_TOKEN = core.getInput(\u0026#39;GITHUB_TOKEN\u0026#39;) const ISSUE_COMMENT = core.getInput(\u0026#39;ISSUE_COMMENT\u0026#39;) if ( typeof GITHUB_TOKEN !== \u0026#39;string\u0026#39; ) { throw new Error(\u0026#39;Invalid GITHUB_TOKEN: did you forget to set it in your action config?\u0026#39;); } if ( typeof ISSUE_COMMENT !== \u0026#39;string\u0026#39;) { throw new Error(\u0026#39;Invalid ISSUE_COMMENT field, it should be a string field\u0026#39;) } const octokit = github.getOctokit(GITHUB_TOKEN) const { issue } = context.payload const payload = context.payload.issue //comment on issue await octokit.rest.issues.createComment({ ...context.repo, issue_number: issue.number, body: ISSUE_COMMENT, }) } catch (e) { core.error(e) core.setFailed(e.message) } } run() The last step would be to create a file namely Dockerfile. If you are not familiar with Docker and Dockerfiles, check out Dockerfile support for GitHub Actions.\nThe Dockerfile will look like:\nFROM node:latest COPY . . RUN npm install --production ENTRYPOINT [\u0026#34;node\u0026#34;, \u0026#34;/dist/index.js\u0026#34;] That\u0026rsquo;s it. We\u0026rsquo;ve created our won Github Action. Now to test it, create a workflow file in .github/workflows and this code:\nname: \u0026#39;Demo Issue Action 🛰\u0026#39; on: issues: types: - opened jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: 🔃 Install run: | yarn - name: 🧱 Build run: | yarn build - uses: ./ with: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} ISSUE_COMMENT: \u0026#39;thanks for raising the issue\u0026#39; How others can use my Action?: The answer is simple just paste the following code in the .github/workflows directory in required repo:\nname: \u0026#39;Demo Issue Action 🛰\u0026#39; on: issues: types: - opened jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: ankur12-1610/demo-action@main with: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} ISSUE_COMMENT: \u0026#39;thanks for raising the issue\u0026#39; #enter custom message And now we are all perfect to launch it in the Github Marketplace.\nPublish the Action to the Marketplace: Go into the the New Release section and you will find this window:\nCreate new release tag, give release heading to the Action and publish it ;)\nFinally, we can find it on https://github.com/marketplace by searching \u0026ldquo;Demo Issue Action 🛰”. Conclusion: Thank you for reading, hope you enjoyed the article! Queries and feedback are most welcome :) kindly leave them below.\nFollow me on Twitter | LinkedIn for more web development-related tips and posts.\nThat\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/github-actions/","summary":"Introduction: Automation, complexity reduction, reproducibility, and maintainability are all advantages that can be realized by a continuous integration (CI) pipeline. With GitHub Actions, you can build these CI pipelines.\n\u0026ldquo;Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you\u0026rsquo;d like, including CI/CD, and combine actions in a completely customized workflow.\u0026rdquo; - Github Docs","title":"Build your own Github Action and publish to the Github Marketplace!"},{"content":" Your profile page tells people the story of your work through the repositories you\u0026rsquo;re interested in, the contributions you\u0026rsquo;ve made, and the conversations you\u0026rsquo;ve had. So, you should put an effort into making your profile stand out.\nOne way to do this is to show your visitors nerdy stats like how much coding you\u0026rsquo;ve been doing, what languages you have been working on and how productive you\u0026rsquo;ve been for the past few days. You can take a look at the screenshot of my Github profile, amazing isn\u0026rsquo;t it.\nPrerequisites: A Github account\nA Github profile README (don\u0026rsquo;t have one, follow docs to create one)\nA WakaTime account (set it up here )\nSteps: To start with, edit your README.md of your Github profile, your repo will be username/username and insert: \u0026lt;!--START_SECTION:waka--\u0026gt; \u0026lt;!--END_SECTION:waka--\u0026gt; wherever you want your code stats to appear.\nNext step is to get your WakaTime API Key from your \u0026ldquo;Account Settings\u0026rdquo; in WakaTime, as shown below:\n![wakatimekey.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1640522009208/8ymf9MgY-.png align=\u0026ldquo;left\u0026rdquo;)\nNext, you\u0026rsquo;ll need to install the WakaTime plugin for your favourite IDE. Look into this page to get information about various plugins for different IDEs. In my case, I prefer VS Code so I installed its VS Code plugin. To set up WakaTime with VS Code visit: https://wakatime.com/vs-code\nNow, head back to your Github repo, go to the \u0026ldquo;Settings\u0026rdquo; tab and then \u0026ldquo;Secrets\u0026rdquo;. Create a new Actions Secret (not an environment one). The name of this secret must be WAKATIME_API_KEY and the value should be the API key obtained in the previous step.\n![secrets.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1640522681567/q05f_0jqv.png align=\u0026ldquo;left\u0026rdquo;)\nNext, create a GitHub workflow with name and directory as specified: .github/workflows/waka.yml. And paste the following code in the newly created workflow:\nname: Waka Readme on: schedule: # Runs every 4 hours - cron: \u0026#39;0 */4 * * *\u0026#39; workflow_dispatch: jobs: update-readme: name: Update Readme with Metrics runs-on: ubuntu-latest steps: - uses: anmol098/waka-readme-stats@master with: WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }} SHOW_OS: \u0026#34;True\u0026#34; SHOW_PROJECTS: \u0026#34;True\u0026#34; SHOW_PROFILE_VIEWS: \u0026#34;False\u0026#34; SHOW_EDITORS: \u0026#34;False\u0026#34; SHOW_LANGUAGE_PER_REPO: \u0026#34;True\u0026#34; SHOW_LOC_CHART: \u0026#34;False\u0026#34; SHOW_LINES_OF_CODE: \u0026#34;True\u0026#34; SHOW_SHORT_INFO: \u0026#34;False\u0026#34; The job runs every 4 hours, in order to make some adjustments, visit: https://crontab.guru.\nNote: It takes time for your stats to appear, you need to log enough time in WakaTime, and give it enough data to actually report.\nConclusion: Thank you for reading, hope you enjoyed the article! Queries and feedback are most welcome :) kindly leave them below.\nFollow me on Twitter | LinkedIn for more web development-related tips and posts.\nThat\u0026rsquo;s all for today! You have read the article till the end.\n","permalink":"https://ankur12-1610.github.io/posts/wakatime-stats/","summary":"Your profile page tells people the story of your work through the repositories you\u0026rsquo;re interested in, the contributions you\u0026rsquo;ve made, and the conversations you\u0026rsquo;ve had. So, you should put an effort into making your profile stand out.\nOne way to do this is to show your visitors nerdy stats like how much coding you\u0026rsquo;ve been doing, what languages you have been working on and how productive you\u0026rsquo;ve been for the past few days.","title":"Showing off your Dev Metrics on your Github Readme profile using WakaTime"},{"content":"","permalink":"https://ankur12-1610.github.io/myjourney/","summary":"","title":""},{"content":"","permalink":"https://ankur12-1610.github.io/projects/","summary":"","title":""}]